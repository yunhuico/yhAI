package documents

import (
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
	"time"
	//	"strings"
	//	"io/ioutil"

	"github.com/Sirupsen/logrus"
	"github.com/emicklei/go-restful"

	"linkernetworks.com/dcos-backend/client/services"
	"linkernetworks.com/dcos-backend/common/persistence/entity"
	"linkernetworks.com/dcos-backend/common/rest/response"
	//	"gopkg.in/mgo.v2/bson"
)

const (
	// alert names must be same with ones in linker-dcos/autoscaling/rulegen/consts/alert.go
	HostHighCPUAlert    = "HostHighCPUAlert"
	HostLowCPUAlert     = "HostLowCPUAlert"
	HostHighMemoryAlert = "HostHighMemoryAlert"
	HostLowMemoryAlert  = "HostLowMemoryAlert"
)

func (p Resource) AlertWebService() *restful.WebService {
	ws := new(restful.WebService)
	ws.Path("/v1/alerts")
	ws.Consumes("*/*")
	ws.Produces(restful.MIME_JSON)

	ws.Route(ws.POST("/").To(p.AlertCreateHandler).
		Doc("Receive an alert").
		Operation("AlertCreateHandler").
		Param(ws.BodyParameter("body", "Alert Body in JSON, normally generated by prometheus.").DataType("string")))

	ws.Route(ws.GET("/").To(p.AlertListHandler).
		Doc("List all alerts").
		Operation("AlertGetHandler").
		Param(ws.QueryParameter("group_id", "Filter results by field GroupID in the alerts")).
		Param(ws.QueryParameter("app_id", "Filter results by field AppID in the alerts")).
		Param(ws.QueryParameter("alert_name", "Filter results by field AlertName of the alerts")).
		Param(ws.QueryParameter("action", "Filter results by field Action of the alerts")).
		Param(ws.QueryParameter("donothing", "If true, the results will contain DO_NOTHING actions")).
		Param(ws.QueryParameter("count", "Count total items and return the result in X-Object-Count header").DataType("boolean")).
		Param(ws.QueryParameter("skip", "Number of items to skip in the result set, default=0")).
		Param(ws.QueryParameter("limit", "Maximum number of items in the result set, default=0")).
		Param(ws.QueryParameter("sort", "Comma separated list of field names to sort")))

	return ws
}

// AlertCreateHandler parses the http request and store an alert.
// Usage :
//		POST /v1/alert
// If successful,response code will be set to 201.
func (p *Resource) AlertCreateHandler(req *restful.Request, resp *restful.Response) {
	logrus.Infof("AlertCreateHandler is called!")

	p.ProcessAlertCall(req)
	//	res := response.Response{Success: true, Data: newAlert}
	res := response.Response{Success: true}
	resp.WriteEntity(res)
	return
}

func (p *Resource) ProcessAlertCall(req *restful.Request) {
	// Read a document from request

	var alertMsg *entity.AlertMessage
	err := json.NewDecoder(req.Request.Body).Decode(&alertMsg)

	if err != nil {
		logrus.Errorf("Decode alert err is %v", err)
		return
	}

	fmt.Printf("Alert is %v\n", alertMsg)

	for _, alert := range alertMsg.Alert {
		if alert.Status == "resolved" {
			logrus.Infof("Get resolved alert, alertname: %s", alert.Labels.AlertName)

		} else {
			// deal with host machine (CPU/Memory) alerts
			alName := alert.Labels.BuiltInAlertName
			if alName == HostHighCPUAlert || alName == HostLowCPUAlert ||
				alName == HostHighMemoryAlert || alName == HostLowMemoryAlert {
				// prevent duplicate emails, ignore alerts which were 1min ago
				startAt, err := time.Parse(time.RFC3339, alert.StartsAt)
				if err != nil {
					logrus.Errorf("parse alert start time error: %v\n", err)
					continue
				}
				if time.Now().Sub(startAt) > 1*time.Minute {
					logrus.Errorf("ignore outdated alert(name: %s,start at %s)\n", alName, alert.StartsAt)
					continue
				}
				hostIP := alert.Labels.HostIP
				// Example Description
				// High memory usage for host machine on 192.168.3.53, (current value: 84.69264)
				var currentVal string
				if arr := strings.Split(alert.Annotations.Description, ":"); len(arr) == 2 {
					currentVal = strings.TrimSpace(strings.TrimRight(arr[1], ")"))
				}
				hostrules, _, err := services.GetHostMonitorService().GetHostRules("x-auth-token")
				if err != nil {
					logrus.Errorf("call host monitor service to query host rules error: %v\n", err)
				}
				errCode, err := services.GetRepairPolicyService().NotifyUser(alName, hostIP, currentVal, *hostrules, startAt)
				if err != nil {
					logrus.Errorf("Failed to call NotifyUser(), errorCode is %s, err is %v\n", errCode, err)
				}
				continue
			}
			// Check if related instance is repairing now.
			result := services.GetAlertService().CheckRelatedRepairs(&alert)
			logrus.Infof("result is %v", result)
			if !result {
				// Set the status to ignored for this alert.
				alert.Status = services.ALERT_MESSAGES_STATUS_IGNORED
			} else {
				logrus.Infof("start to create alert.")
				newAlert, _, err := services.GetAlertService().Create(alert)
				if err != nil {
					logrus.Errorf("Create alert in db failed, err is %v", err)
				}
				// start to repair
				groupId := newAlert.Labels.GroupId
				appid := newAlert.Labels.AppId
				repairTempalteId := "/" + newAlert.Labels.RepairTempalteId
				serviceGroupInsanceId := newAlert.Labels.ServiceGroupInstanceId
				orderId := newAlert.Labels.ServiceOrderId
				alertId := newAlert.ObjectId.Hex()
				alertName := newAlert.Labels.AlertName

				fmt.Printf("Debug: repairTempalteId%s, groupId%s, appid%s,serviceGroupInsanceId%s,orderId%s,alertId%s,alertName%s\n", repairTempalteId, groupId, appid, serviceGroupInsanceId, orderId, alertId, alertName)

				errorCode, err := services.GetRepairPolicyService().AnalyzeAlert(repairTempalteId, groupId, appid, serviceGroupInsanceId, orderId, alertId, alertName, "")
				if err != nil {
					logrus.Errorf("Failed to call analyze errorCode is %s, err is %v \n", errorCode, err)
				}
			}

		}
	}

}

func (p *Resource) AlertListHandler(req *restful.Request, resp *restful.Response) {
	logrus.Infof("AlertListHandler is called!")

	skip := queryIntParam(req, "skip", 0)
	limit := queryIntParam(req, "limit", 0)
	sort := req.QueryParameter("sort")
	groupID := req.QueryParameter("group_id")
	appID := req.QueryParameter("app_id")
	alertName := req.QueryParameter("alert_name")
	action := req.QueryParameter("action")
	doNothing, err := queryBoolParam(req, "donothing", false)
	if err != nil {
		response.WriteStatusError(services.COMMON_ERROR_INVALIDATE, err, resp)
		return
	}

	// logrus.Infof("app_id: %s, alert_name: %s, action: %s\n", appID, alertName, action)

	//query alerts
	total, alerts, errorCode, err := services.GetAlertService().ListAlerts(groupID, appID, alertName, action, doNothing, skip, limit, sort)
	if err != nil {
		response.WriteStatusError(errorCode, err, resp)
		return
	}

	res := response.QueryStruct{Success: true, Data: alerts}
	if c, _ := strconv.ParseBool(req.QueryParameter("count")); c {
		res.Count = total
		resp.AddHeader("X-Object-Count", strconv.Itoa(total))
	}

	resp.WriteEntity(res)
	return
}
